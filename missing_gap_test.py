#!/usr/bin/env python3
#
# Copyright 2020 Seth Troisi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import multiprocessing
import re
import time

import gmpy2
import tqdm

import gap_utils


def get_arg_parser():
    parser = argparse.ArgumentParser(
        "Test possible missing prime gaps generated by gap_stats")

    parser.add_argument('--save-logs', action='store_true',
        help="Save output to .log file")

    parser.add_argument("-t", "--threads", type=int, default=1, nargs="?",
        help="Number of threads to test with (default: %(default)s)")

    parser.add_argument("--unknown-filename", type=str,
        help="mstart, minc, p, d, sieve-length, and sieve-range"
             " are determined from filename")

    parser.add_argument("-i", "--ignore-gaps", type=int,
        nargs="*", metavar="GAPS", default=[],
        help="Ignore these gap sizes")

    return parser


def parse_unknown_lines(args):
    with open(args.unknown_filename) as unknown_file:
        p_last = 1.0
        processed = []
        # TODO tqdm
        for line in tqdm.tqdm(unknown_file.readlines()):
            line = line.strip()
            if not line: continue

            prob, start, tests = line.split(" : ")
            prob = float(prob)

            # parsing to int_tests uses 8x space,
            # runs on main thread not worker threads,
            # passing 20k character strings is fast.
            processed.append((prob, start, line.count(","), line))

            assert prob <= p_last, (prob, p_last)
            p_last = prob

    return processed

# -----

# Makes tested/second much more stable
g_tested = multiprocessing.Value('i', 0)

# See Pool and initializer which set test_line.ignore_gaps
def init_worker(function, ignore):
    function.ignore_gaps = ignore


def test_line(data):
    prob, start, test_count, tests = data

    m, p, d = re.match(r"(\d+)\*(\d+)#\/(\d+)", start.replace(' ', '')).groups()
    m, p, d = map(int, (m, p, d))
    #assert p == str(P) and d == str(D), (p, d, P, D)

    K, r = divmod(gmpy2.primorial(p), d)
    assert r == 0
    N = m * K

    cache = {}

    # Might make more sense to use multiprocessing.Queue and
    skipped = 0
    tested = 0
    primes = 0

    success = []
    max_high = None
    max_low  = None
    last_low = None
    last_low_status = False

    for low, high in re.findall("(\d+),(\d+)", tests):
        low, high = int(low), int(high)

        if max_high and high > max_high:
            continue

        if max_low and low > max_low:
            continue

        if (low + high) in test_line.ignore_gaps:
            skipped += 1
            continue

        if low not in cache:
            with g_tested.get_lock(): g_tested.value += 1
            tested += 1
            cache[low] = gap_utils.is_prime(N - low, start, "-" + str(low))
            if cache[low]:
                max_low = low
                primes += 1

        if not cache[low]:
            continue

        if high not in cache:
            with g_tested.get_lock(): g_tested.value += 1
            tested += 1
            cache[high] = gap_utils.is_prime(N + high, start, "+" + str(high))
            if cache[high]:
                max_high = high
                primes += 1

        if cache[high]:
            # Should never be more than one success:
            # if low,high happen in reasonable order after first pair of
            # primes all larger intervals are invalid.
            succ = "BOTH PRIME: {} -{} to +{}".format(start, low, high)

            success.append(succ)
            print("\n"*3)
            print("\t", succ)
            print("\n"*3)

    return prob, start, test_count, skipped, tested, primes, success


def prime_gap_test(args):
    P = args.p
    D = args.d

    # used in next_prime
    assert P <= 80000
    K = gmpy2.primorial(P)
    K, r = divmod(K, D)
    assert r == 0

    K_digits = gmpy2.num_digits(K, 10)
    K_bits   = gmpy2.num_digits(K, 2)
    K_log    = float(gmpy2.log(K))
    print("K = {} bits, {} digits, log(K) = {:.2f}".format(
        K_bits, K_digits, K_log))
    print()

    # ----- Open missing gap input file
    print("Loading unknowns from '{}'".format(args.unknown_filename))
    print()

    if args.ignore_gaps:
        print ("\tSkipping gaps: {}".format(
            ", ".join(map(str, args.ignore_gaps))))

    # Used for various stats
    s_start_t = time.time()
    s_last_print_t = time.time()

    def print_timing(prefix, count):
        secs = time.time() - s_start_t

        # Want 3 sig figs which is hard in python
        def roundSig(n, sig):
            return '{:g}'.format(float('{:.{p}g}'.format(n, p=sig)))

        if count and count < secs:
            timing = "{} secs/test".format(roundSig(secs / count, 3))
        else:
            timing = "{}/sec".format(roundSig(count / secs, 3))

        print("\t{:12} {:10d} tests ({})  {:.0f} seconds elapsed".format(
            prefix, count, timing, secs))

    successes = []
    summed_prob = 0
    skipped_prob = 0
    skipped = 0
    tested = 0
    primes = 0

    lines = parse_unknown_lines(args)

    # TODO assert lines are sorted
    print("Read {} lines with missing_gap_prob: {:.3g} to {:.3g}".format(
        len(lines), lines[0][0], lines[-1][0]))

    # Pass *init_args to initializer
    init_args = (test_line, args.ignore_gaps)

    with multiprocessing.Pool(args.threads, init_worker, init_args) as pool:
        for li, (prob, start, test_count, line_s, line_t, line_p, line_suc) in \
                enumerate(pool.imap_unordered(test_line, lines)):

            ratio = 1 - line_s / test_count
            summed_prob += prob * ratio
            skipped += line_s
            tested  += line_t
            primes  += line_p
            successes.extend(line_suc)


            if line_s == 0:
                pair_print = "{:<4}".format(test_count)
                prob_print   = "{:.2e}".format(summed_prob)
            else:
                pair_print = "{:4}/{:<4}".format(test_count - line_s, test_count)
                prob_print   = "{:.2e}/{:.2e}".format(ratio * prob, prob)

            print("finished: {} ({} from {} pairs)\t|".format(
                start, prob_print, pair_print, test_count),
                end = " ")
            print("m: {}/{}, p/t: {}/{}, sum(prob): {:.4f}".format(
                li + 1, len(lines),
                primes, tested,
                summed_prob))

            s_stop_t = time.time()
            print_secs = s_stop_t - s_last_print_t
            if li in (1,2,5,10,20,50) or li % 100 == 0 or print_secs > 240:
                secs = s_stop_t - s_start_t
                s_last_print_t = s_stop_t

                with g_tested.get_lock():
                    print_timing(li + 1, g_tested.value)

    # TODO print more stats at the end
    print_timing("END: " + str(li + 1), tested)

    print("\n"*2)
    for success in successes:
        print("\t", success)
    print("\n"*2)


if __name__ == "__main__":
    parser = get_arg_parser()
    args = parser.parse_args()
    gap_utils.verify_args(args, ".missing")

    # TeeLogger context if args.save_logs
    with gap_utils.logger_context(args):
        prime_gap_test(args)


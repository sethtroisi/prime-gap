#!/usr/bin/env python3
#
# Copyright 2020 Seth Troisi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import multiprocessing
import os.path
import re
import subprocess
import time

import gmpy2

import gap_utils


def get_arg_parser():
    parser = argparse.ArgumentParser(
        'Test possible missing prime gaps generated by gap_stats')

    parser.add_argument('--unknown-filename', type=str,
        help="determine mstart, minc, p, d, sieve-length, and sieve-range"
             " from unknown-results filename")

    return parser


# Makes tested/second much more stable
g_tested = multiprocessing.Value('i', 0)

def test_line(data):
    _, start, to_test = data

    m, p, d = re.match(r"(\d+)\*(\d+)#\/(\d+)", start.replace(' ', '')).groups()
    m, p, d = map(int, (m, p, d))
    #assert p == str(P) and d == str(D), (p, d, P, D)

    K = gmpy2.primorial(p)
    K, r = divmod(K, d)
    assert r == 0
    N = m * K

    cache = {}

    # Might make more sense to use multiprocessing.Queue and
    tested = 0
    primes = 0

    success = []
    max_high = None
    max_low  = None
    last_low = None
    last_low_status = False
    for match in re.findall("(\d+,\d+)", to_test):
        low, high = map(int, match.split(","))

        if max_high and high > max_high:
            continue

        if max_low and low > max_low:
            continue

        if low not in cache:
            with g_tested.get_lock(): g_tested.value += 1
            tested += 1
            cache[low] = gap_utils.is_prime(N - low, start, "-" + str(low))
            if cache[low]:
                max_low = low
                primes += 1

        if not cache[low]:
            continue

        if high not in cache:
            with g_tested.get_lock(): g_tested.value += 1
            tested += 1
            cache[high] = gap_utils.is_prime(N + high, start, "+" + str(high))
            if cache[high]:
                max_high = high
                primes += 1

        if cache[high]:
            # Should never be more than one success:
            # if low,high happen in reasonable order after first pair of
            # primes all larger intervals are invalid.
            success.append((start, low, high))
            print("\n"*3)
            print("\tBOTH SIDES PRIME:", start, low, high)
            print("\n"*3)

    return data, tested, primes, success


def prime_gap_test(args):
    P = args.p
    D = args.d

    # used in next_prime
    assert P <= 80000
    K = gmpy2.primorial(P)
    K, r = divmod(K, D)
    assert r == 0

    K_digits = gmpy2.num_digits(K, 10)
    K_bits   = gmpy2.num_digits(K, 2)
    K_log    = float(gmpy2.log(K))
    print("K = {} bits, {} digits, log(K) = {:.2f}".format(
        K_bits, K_digits, K_log))

    # ----- Open Output file
    print("\tLoading unknowns from '{}'".format(args.unknown_filename))
    print()

    # Used for various stats
    s_start_t = time.time()
    s_last_print_t = time.time()

    def print_timing(a, count):
        secs = time.time() - s_start_t

        def roundSig(n, sig):
            return '{:g}'.format(float('{:.{p}g}'.format(n, p=sig)))

        # Want 3 sig figs which is hard in python
        if count and count < secs:
            timing = "{} secs/test".format(roundSig(secs / count, 3))
        else:
            timing = "{}/sec".format(roundSig(count / secs, 3))

        print("\t{:12} {:10d} tests ({})  {:.0f} seconds elapsed".format(
            a, count, timing, secs))

    with open(args.unknown_filename) as unknown_file:
        # hope this doesn't run out of memory
        lines = (line.split(" : ") for line in unknown_file.readlines())
        # TODO verify lines are sorted in gap_stats.cpp
        # lines = sorted(((float(p), s, t) for p,s,t in lines), reverse=True)
        lines = [(float(p), s, t) for p,s,t in lines]
        print("Read {} lines with missing_gap_prob: {:.3g} to {:.3g}".format(
            len(lines), lines[0][0], lines[-1][0]))
        print ()

        success = []
        tested_m = 0
        summed_prob = 0
        tested = 0
        primes = 0

        # TODO configureable argument
        with multiprocessing.Pool(10) as pool:
            for li, (line, line_t, line_p, line_s) in enumerate(pool.imap_unordered(test_line, lines)):
                missing_gap_prob, start, to_test = line

                summed_prob += missing_gap_prob
                tested_m += 1

                tested += line_t
                primes += line_p
                success.extend(line_s)

                print("finished: {} ({:.2g} from {:<4} pairs)\t|".format(
                    start, missing_gap_prob, to_test.count('(')),
                    end = " ")
                print("m: {}/{}, p/t: {}/{}, sum(prob): {:.4f}".format(
                    tested_m, len(lines),
                    primes, tested,
                    summed_prob))

                s_stop_t = time.time()
                print_secs = s_stop_t - s_last_print_t
                if li in (1,2,5,10,20,50) or li % 100 == 0 or print_secs > 240:
                    secs = s_stop_t - s_start_t
                    s_last_print_t = s_stop_t

                    with g_tested.get_lock():
                        print_timing(tested_m, g_tested.value)

        # TODO print more stats at the end
        print_timing("END: " + str(tested_m), tested)

        print("\n"*2)
        for s in success:
            print("\tBOTH SIDES PRIME:", *s)
        print("\n"*2)


if __name__ == "__main__":
    parser = get_arg_parser()
    args = parser.parse_args()
    gap_utils.verify_args(args)

    # TODO TeeLogger from gap_test

    prime_gap_test(args)


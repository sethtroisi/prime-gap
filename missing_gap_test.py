#!/usr/bin/env python3
#
# Copyright 2020 Seth Troisi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import multiprocessing
import os.path
import re
import subprocess
import time

import gmpy2


def get_arg_parser():
    parser = argparse.ArgumentParser('Test prime gaps generated by gap_search')

    parser.add_argument('--unknown-filename', type=str,
        help="determine mstart, minc, p, d, sieve-length, and sieve-range"
             " from unknown-results filename")

    return parser


def verify_args(args):
    if args.unknown_filename:
        fn = args.unknown_filename
        if not os.path.exists(fn):
            print ("\"{}\" doesn't exist".format(fn))
            exit(1)
        match = re.match(
            "^(\d+)_(\d+)_(\d+)_(\d+)_s(\d+)_l(\d+)M.(?:m2.)?missing.txt",
            os.path.basename(fn))
        if not match:
            print ("\"{}\" doesn't match unknown file format".format(fn))
            exit(1)

        ms, p, d, mi, sl, sr = map(int, match.groups())
        args.mstart = ms
        args.minc = mi
        args.p = p
        args.d = d
        args.sieve_length = sl
        args.sieve_range = sr * 10 ** 6

    for arg in ('mstart', 'minc', 'p', 'd',):
        if arg not in args or args.__dict__[arg] in (None, 0):
            print ("Missing required argument", arg)
            exit(1)


    fn = "{}_{}_{}_{}_s{}_l{}M.m2.missing.txt".format(
        args.mstart, args.p, args.d, args.minc,
        args.sieve_length, args.sieve_range // 10 ** 6)

    if args.unknown_filename:
        assert fn == os.path.basename(args.unknown_filename), (fn, args.unknown_filename)
    else:
        args.unknown_filename = fn


def openPFGW_is_prime(strn):
    # Overhead of subprocess calls seems to be ~0.03
    s = subprocess.getstatusoutput(f"./pfgw64 -e1 -q'{strn}'")
    assert s[1].startswith('PFGW'), s
    return s[0] == 0


def is_prime(num, strnum):
    # TODO print log of which library is being used.
    if gmpy2.num_digits(num, 2) > 5000:
        return openPFGW_is_prime(strnum)

    return gmpy2.is_prime(num)


def test_line(data):
    _, start, to_test = data

    m, p, d = re.match(r"(\d+)\*(\d+)#\/(\d+)", start.replace(' ', '')).groups()
    m, p, d = map(int, (m, p, d))
    #assert p == str(P) and d == str(D), (p, d, P, D)

    K = gmpy2.primorial(p)
    K, r = divmod(K, d)
    assert r == 0
    N = m * K

    cache = {}

    # Might make more sense to use multiprocessing.Queue and
    tested = 0
    primes = 0

    success = []
    max_high = None
    max_low  = None
    last_low = None
    last_low_status = False
    for match in re.findall("(\d+,\d+)", to_test):
        low, high = map(int, match.split(","))

        if max_high and high > max_high:
            continue

        if max_low and low > max_low:
            continue

        if low not in cache:
            tested += 1
            cache[low] = is_prime(N - low, start + "-" + str(low))
            if cache[low]:
                max_low = low
                primes += 1

        if not cache[low]:
            continue

        if high not in cache:
            tested += 1
            cache[high] = is_prime(N + high, start + "+" + str(high))
            if cache[high]:
                max_high = high
                primes += 1

        if cache[high]:
            # Should never be more than one success:
            # if low,high happen in reasonable order after first pair of
            # primes all larger intervals are invalid.
            success.append((start, low, high))
            print("\n"*3)
            print("\tBOTH SIDES PRIME:", start, low, high)
            print("\n"*3)

    return data, tested, primes, success


def prime_gap_test(args):
    P = args.p
    D = args.d

    # used in next_prime
    assert P <= 80000
    K = gmpy2.primorial(P)
    K, r = divmod(K, D)
    assert r == 0

    K_digits = gmpy2.num_digits(K, 10)
    K_bits   = gmpy2.num_digits(K, 2)
    K_log    = float(gmpy2.log(K))
    print("K = {} bits, {} digits, log(K) = {:.2f}".format(
        K_bits, K_digits, K_log))

    # ----- Open Output file
    print("\tLoading unknowns from '{}'".format(args.unknown_filename))
    print()

    # Used for various stats
    s_start_t = time.time()
    s_last_print_t = time.time()

    def print_timing(a, count):
        secs = time.time() - s_start_t

        def roundSig(n, sig):
            return '{:g}'.format(float('{:.{p}g}'.format(n, p=sig)))

        # Want 3 sig figs which is hard in python
        if count and count < secs:
            timing = "{} secs/test".format(roundSig(secs / count, 3))
        else:
            timing = "{}/sec".format(roundSig(count / secs, 3))

        print("\t{:12s} {:10d} tests ({})  {:.0f} seconds elapsed".format(
            a, count, timing, secs))

    with open(args.unknown_filename) as unknown_file:
        # hope this doesn't run out of memory
        lines = (line.split(" : ") for line in unknown_file.readlines())
        # TODO verify lines are sorted in gap_stats.cpp
        # lines = sorted(((float(p), s, t) for p,s,t in lines), reverse=True)
        lines = [(float(p), s, t) for p,s,t in lines]
        print("Read {} lines with missing_gap_prob: {:.3g} to {:.3g}".format(
            len(lines), lines[0][0], lines[-1][0]))
        print ()

        success = []
        tested_m = 0
        summed_prob = 0
        tested = 0
        primes = 0

        # TODO configureable argument
        with multiprocessing.Pool(10) as pool:
            for li, (line, line_t, line_p, line_s) in enumerate(pool.imap(test_line, lines)):
                missing_gap_prob, start, to_test = line

                summed_prob += missing_gap_prob
                tested_m += 1

                tested += line_t
                primes += line_p
                success.extend(line_s)

                print("finished: {} ({:.2g} from {:<4} pairs)\t|".format(
                    start, missing_gap_prob, to_test.count('(')),
                    end = " ")
                print("m: {}, p/t: {}/{}, sum(prob): {:.4f}".format(
                    tested_m, primes, tested, summed_prob))

                s_stop_t = time.time()
                print_secs = s_stop_t - s_last_print_t
                if li in (1,10,30,100,300,1000) or li % 5000 == 0 or print_secs > 240:
                    secs = s_stop_t - s_start_t
                    s_last_print_t = s_stop_t

                    print_timing(tested_m, tested)

        # TODO print more stats at the end
        print_timing("END: " + str(tested_m), tested)

        print("\n"*2)
        for s in success:
            print("\tBOTH SIDES PRIME:", *s)
        print("\n"*2)

if __name__ == "__main__":
    parser = get_arg_parser()
    args = parser.parse_args()
    verify_args(args)

    prime_gap_test(args)

